# Design Document

## Overview

This document describes the technical solution for fixing two drag-and-drop bugs in the Workout SPA Editor:

1. **Content Swap Bug**: Cards swap content instead of positions due to content-based IDs
2. **Visual Bug**: Repetition block drag previews appear compressed during drag operations

The root cause of the content swap bug is that the DnD system generates IDs based on `stepIndex` (content property), which changes during reordering. This causes React to incorrectly reconcile DOM elements, resulting in content swapping instead of position swapping.

The visual bug occurs because the drag preview doesn't properly inherit the dimensions of repetition block cards, which are larger and more complex than regular step cards.

## Architecture

### Current Implementation (Problematic)

```
useWorkoutListDnd Hook
  ↓
generateStepId(step, index)
  ↓
Uses step.stepIndex (content-based)
  ↓
ID: "step-{stepIndex}"
  ↓
When reordered, stepIndex changes
  ↓
React sees different IDs → swaps content
```

### Proposed Implementation (Fixed)

```
useWorkoutListDnd Hook
  ↓
generateStepId(step, index)
  ↓
Uses array index (position-based)
  ↓
ID: "step-{arrayIndex}" or "block-{arrayIndex}"
  ↓
When reordered, IDs reflect new positions
  ↓
React tracks elements correctly → swaps positions
```

## Components and Interfaces

### Modified Hook: `use-workout-list-dnd.ts`

**Current problematic implementation:**

```typescript
const generateStepId = (
  step: WorkoutStep | RepetitionBlock,
  index: number
): string => {
  if (isWorkoutStep(step)) {
    // ❌ PROBLEM: Uses stepIndex from content
    return `step-${step.stepIndex}`;
  }
  return `block-${step.repeatCount}-${index}`;
};
```

**Fixed implementation:**

```typescript
const generateStepId = (
  step: WorkoutStep | RepetitionBlock,
  index: number
): string => {
  if (isWorkoutStep(step)) {
    // ✅ FIX: Use array index (position-based)
    return `step-${index}`;
  }
  // ✅ FIX: Use array index for blocks too
  return `block-${index}`;
};
```

### Key Changes

1. **Remove dependency on `step.stepIndex`**: This property changes during reordering
2. **Use array `index` parameter**: This reflects the element's position in the array
3. **Simplify block IDs**: Remove `repeatCount` from ID since it's also content-based

### Impact on Selection System

The selection system currently uses IDs in the format `step-{stepIndex}`. We need to ensure compatibility:

**Option 1: Update selection system to use position-based IDs**

- Pros: Consistent ID system across the app
- Cons: Requires changes to selection logic

**Option 2: Maintain separate ID systems**

- Pros: Minimal changes to existing code
- Cons: Two different ID formats (confusing)

**Recommended: Option 1** - Update selection system for consistency.

## Data Models

### ID Format Changes

**Before:**

```typescript
// Step IDs based on stepIndex (content)
("step-0", "step-1", "step-2"); // stepIndex values

// Block IDs based on repeatCount and index
("block-3-0", "block-5-1"); // repeatCount-index
```

**After:**

```typescript
// Step IDs based on array position
("step-0", "step-1", "step-2"); // array indices

// Block IDs based on array position
("block-0", "block-1"); // array indices
```

### State Updates

The `reorderStepAction` already correctly:

1. Reorders the array using `splice`
2. Updates `stepIndex` values via `reindexSteps`
3. Returns new state with updated workout

No changes needed to the state management logic.

## Correctness Properties

_A property is a characteristic or behavior that should hold true across all valid executions of a system-essentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees._

### Property 1: Position-based ID generation

_For any_ workout step or repetition block at array position `i`, the generated ID SHALL be `step-{i}` or `block-{i}` respectively, using only the array index and not any content properties.

**Validates: Requirements 2.1**

### Property 2: Stable IDs during content changes

_For any_ workout step at array position `i`, if the step's content changes (including `stepIndex`), the generated ID SHALL remain `step-{i}` as long as the array position hasn't changed.

**Validates: Requirements 2.2**

### Property 3: ID regeneration after reorder

_For any_ reorder operation that moves a step from position `i` to position `j`, the ID generation SHALL produce new IDs that reflect the new array positions for all affected steps.

**Validates: Requirements 2.3**

### Property 4: Sequential stepIndex after reorder

_For any_ workout after a reorder operation, the `stepIndex` values SHALL be sequential starting from 0, matching the array positions.

**Validates: Requirements 1.3**

### Property 5: React key matches generated ID

_For any_ rendered workout item, the React `key` prop SHALL match the ID generated by `generateStepId` for that item's array position.

**Validates: Requirements 2.4**

### Property 6: Drag preview dimension preservation

_For any_ repetition block card being dragged, the drag overlay dimensions SHALL be within 10% of the original card's width and height.

**Validates: Requirements 3.1, 3.2**

### Property 7: Dimension restoration after drop

_For any_ repetition block card after being dropped, the card dimensions SHALL match its dimensions before the drag operation started.

**Validates: Requirements 3.3**

### Property 8: Consistent drag visual treatment

_For any_ draggable card (step or block), the drag preview SHALL apply the same opacity and transform styles regardless of card type.

**Validates: Requirements 3.4**

## Drag Preview Fix for Repetition Blocks

### Problem Analysis

The `useSortable` hook from @dnd-kit applies transforms to the original element during drag. For repetition blocks, which have complex nested content, the transform may not properly account for the full dimensions.

### Solution Options

**Option A: Custom DragOverlay**

Add a `DragOverlay` component to render a custom preview:

```typescript
import { DragOverlay } from '@dnd-kit/core';

<DndContext ...>
  <SortableContext ...>
    {/* sortable items */}
  </SortableContext>
  <DragOverlay>
    {activeId ? <CustomPreview id={activeId} /> : null}
  </DragOverlay>
</DndContext>
```

**Option B: CSS Fixes**

Ensure the sortable wrapper preserves dimensions:

```typescript
const style = {
  transform: CSS.Transform.toString(transform),
  transition,
  opacity: isDragging ? 0.5 : 1,
  // ✅ Add dimension preservation
  width: isDragging ? "auto" : undefined,
  height: isDragging ? "auto" : undefined,
};
```

**Option C: Clone Strategy**

Use `useSortable` with a clone strategy that preserves dimensions:

```typescript
const { setNodeRef, transform, transition, isDragging } = useSortable({
  id,
  // ✅ Add data for dimension preservation
  data: {
    type: "repetition-block",
    // Store dimensions if needed
  },
});
```

**Recommended: Option A** - Most reliable and provides full control over preview rendering.

## Error Handling

### Invalid Index Handling

The existing `validateIndices` function already handles invalid indices:

```typescript
const validateIndices = (
  activeIndex: number,
  overIndex: number,
  stepsLength: number
): boolean => {
  return (
    activeIndex >= 0 &&
    activeIndex < stepsLength &&
    overIndex >= 0 &&
    overIndex < stepsLength
  );
};
```

No changes needed.

### Edge Cases

1. **Empty workout**: No steps to reorder → no-op
2. **Single step**: Cannot reorder → no-op
3. **Same position**: `activeIndex === overIndex` → early return (already handled)
4. **Out of bounds**: Caught by `validateIndices` → early return

All edge cases are already handled correctly.

## Testing Strategy

### Unit Tests

**Test 1: ID generation uses array index**

```typescript
it("should generate IDs based on array index, not stepIndex", () => {
  // Arrange
  const step1: WorkoutStep = { stepIndex: 5 /* ... */ };
  const step2: WorkoutStep = { stepIndex: 10 /* ... */ };
  const workout = { steps: [step1, step2] };

  // Act
  const ids = workout.steps.map((step, index) => generateStepId(step, index));

  // Assert
  expect(ids).toEqual(["step-0", "step-1"]);
  // NOT ['step-5', 'step-10']
});
```

**Test 2: IDs remain stable when content changes**

```typescript
it("should maintain stable IDs when stepIndex changes", () => {
  // Arrange
  const step: WorkoutStep = { stepIndex: 0 /* ... */ };
  const id1 = generateStepId(step, 0);

  // Act - simulate stepIndex change
  step.stepIndex = 5;
  const id2 = generateStepId(step, 0);

  // Assert
  expect(id1).toBe(id2); // Both should be 'step-0'
});
```

**Test 3: Block IDs use array index**

```typescript
it("should generate block IDs based on array index", () => {
  // Arrange
  const block: RepetitionBlock = { repeatCount: 3, steps: [] };

  // Act
  const id = generateStepId(block, 2);

  // Assert
  expect(id).toBe("block-2");
  // NOT 'block-3-2'
});
```

### Integration Tests

**Test 4: Reorder updates IDs correctly**

```typescript
it("should update IDs after reordering", () => {
  // Arrange
  const workout = {
    steps: [{ stepIndex: 0 }, { stepIndex: 1 }, { stepIndex: 2 }],
  };

  // Act - reorder: move index 0 to index 2
  const reordered = reorderSteps(workout, 0, 2);
  const ids = reordered.steps.map((step, index) => generateStepId(step, index));

  // Assert
  expect(ids).toEqual(["step-0", "step-1", "step-2"]);
  // IDs based on new positions, not old stepIndex values
});
```

### E2E Tests (Playwright)

**Test 5: Visual position swap**

```typescript
test("should physically swap card positions on drag-and-drop", async ({
  page,
}) => {
  // Arrange
  await page.goto("/");
  await loadWorkoutWithSteps(page, 3);

  const card1 = page.locator('[data-testid="step-card-0"]');
  const card2 = page.locator('[data-testid="step-card-1"]');

  // Get initial text content
  const card1Text = await card1.textContent();
  const card2Text = await card2.textContent();

  // Act - drag card1 over card2
  await card1.dragTo(card2);

  // Assert - cards should swap positions, not content
  await expect(card1).toHaveText(card2Text); // card1 now has card2's content
  await expect(card2).toHaveText(card1Text); // card2 now has card1's content

  // Verify DOM elements actually moved
  const newCard1 = page.locator('[data-testid="step-card-0"]');
  const newCard2 = page.locator('[data-testid="step-card-1"]');
  await expect(newCard1).toHaveText(card2Text);
  await expect(newCard2).toHaveText(card1Text);
});
```

**Test 6: Repetition block drag preview dimensions**

```typescript
test("should maintain correct dimensions for repetition block drag preview", async ({
  page,
}) => {
  // Arrange
  await page.goto("/");
  await loadWorkoutWithRepetitionBlock(page);

  const blockCard = page.locator('[data-testid="repetition-block-0"]');
  const originalBox = await blockCard.boundingBox();

  // Act - start dragging
  await blockCard.hover();
  await page.mouse.down();
  await page.mouse.move(originalBox.x + 50, originalBox.y + 50);

  // Assert - drag preview should have similar dimensions
  const dragPreview = page.locator(".dnd-drag-overlay"); // or appropriate selector
  const previewBox = await dragPreview.boundingBox();

  expect(previewBox.width).toBeCloseTo(originalBox.width, 10); // within 10px
  expect(previewBox.height).toBeCloseTo(originalBox.height, 10);

  // Cleanup
  await page.mouse.up();
});
```

**Test 7: Data integrity after reorder**

```typescript
test("should update workout data correctly after reorder", async ({ page }) => {
  // Arrange
  await page.goto("/");
  await loadWorkoutWithSteps(page, 3);

  // Act - reorder steps
  const card1 = page.locator('[data-testid="step-card-0"]');
  const card3 = page.locator('[data-testid="step-card-2"]');
  await card1.dragTo(card3);

  // Assert - check workout data via store or API
  const workoutData = await page.evaluate(() => {
    return window.__WORKOUT_STORE__.getState().currentWorkout;
  });

  expect(workoutData.extensions.workout.steps[0].stepIndex).toBe(0);
  expect(workoutData.extensions.workout.steps[1].stepIndex).toBe(1);
  expect(workoutData.extensions.workout.steps[2].stepIndex).toBe(2);
  // stepIndex values should be sequential after reorder
});
```

## Implementation Notes

### Migration Path

1. **Update `generateStepId` function** in `use-workout-list-dnd.ts`
2. **Add unit tests** for ID generation
3. **Update E2E tests** to verify physical position swaps
4. **Add DragOverlay** for repetition block preview fix
5. **Test thoroughly** with various workout configurations

### Backward Compatibility

The change to position-based IDs is **not backward compatible** with saved selections that use content-based IDs. However, since selections are ephemeral (not persisted), this is acceptable.

### Performance Considerations

- ID generation is O(1) per item
- No performance impact from using array index vs. stepIndex
- DragOverlay may have slight rendering overhead, but negligible

## References

- [@dnd-kit Documentation](https://docs.dndkit.com/)
- [React Keys and Reconciliation](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)
- [DragOverlay API](https://docs.dndkit.com/api-documentation/draggable/drag-overlay)
