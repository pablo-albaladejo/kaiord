name: Changesets

on:
  push:
    branches:
      - main

concurrency: ${{ github.workflow }}-${{ github.ref }}

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  version:
    name: Version Packages
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20.x

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Get pnpm store directory
        id: pnpm-cache
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Create Release Pull Request or Publish
        id: changesets
        # Changesets action handles version bumping and changelog generation
        # Creates/updates "Version Packages" PR when changesets are present
        uses: changesets/action@v1
        with:
          version: pnpm exec changeset version
          commit: "chore: version packages"
          title: "chore: version packages"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create GitHub Releases
        # Automatically create GitHub releases when Version Packages PR is merged
        # Creates separate release for each updated package with package-scoped tags
        # Handles failures independently - continues processing other packages if one fails
        if: steps.changesets.outputs.hasChangesets == 'false'
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');

            // Track results for summary
            const results = {
              successful: [],
              failed: [],
              skipped: []
            };

            // Read package.json files to get versions and changelogs
            const packages = [];

            // Check @kaiord/core
            if (fs.existsSync('packages/core/package.json')) {
              const corePackage = JSON.parse(fs.readFileSync('packages/core/package.json', 'utf8'));
              let coreChangelog = '';
              if (fs.existsSync('packages/core/CHANGELOG.md')) {
                coreChangelog = fs.readFileSync('packages/core/CHANGELOG.md', 'utf8');
              }
              packages.push({
                name: corePackage.name,
                version: corePackage.version,
                changelog: coreChangelog,
                dir: 'packages/core'
              });
            }

            // Check @kaiord/cli
            if (fs.existsSync('packages/cli/package.json')) {
              const cliPackage = JSON.parse(fs.readFileSync('packages/cli/package.json', 'utf8'));
              let cliChangelog = '';
              if (fs.existsSync('packages/cli/CHANGELOG.md')) {
                cliChangelog = fs.readFileSync('packages/cli/CHANGELOG.md', 'utf8');
              }
              packages.push({
                name: cliPackage.name,
                version: cliPackage.version,
                changelog: cliChangelog,
                dir: 'packages/cli'
              });
            }

            if (packages.length === 0) {
              console.log('No packages found to release');
              return;
            }

            // Get the commit that triggered this workflow
            const commit = context.sha;

            // Check which packages were actually updated in this commit
            const changedFiles = execSync(`git diff-tree --no-commit-id --name-only -r ${commit}`, { encoding: 'utf8' });

            const updatedPackages = packages.filter(pkg => {
              const packageJsonPath = `${pkg.dir}/package.json`;
              return changedFiles.includes(packageJsonPath);
            });

            if (updatedPackages.length === 0) {
              console.log('No packages were updated in this commit');
              return;
            }

            console.log(`\nðŸ“¦ Processing ${updatedPackages.length} package(s) for release...\n`);

            // Create a release for each updated package
            // Process independently - failures don't block other packages
            for (const pkg of updatedPackages) {
              const tagName = `${pkg.name}@${pkg.version}`;
              
              try {
                // Check if release already exists
                try {
                  const existingRelease = await github.rest.repos.getReleaseByTag({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    tag: tagName
                  });
                  console.log(`â„¹ï¸  Release ${tagName} already exists: ${existingRelease.data.html_url}`);
                  results.skipped.push({
                    package: pkg.name,
                    version: pkg.version,
                    reason: 'Release already exists',
                    url: existingRelease.data.html_url
                  });
                  continue;
                } catch (error) {
                  if (error.status !== 404) {
                    throw error;
                  }
                  // Release doesn't exist, continue to create it
                }

                // Build release notes
                let releaseNotes = `## ðŸ“¦ ${pkg.name}\n\n`;
                releaseNotes += `**Version:** ${pkg.version}\n`;
                releaseNotes += `**npm:** [${pkg.name}@${pkg.version}](https://www.npmjs.com/package/${pkg.name}/v/${pkg.version})\n\n`;

                // Extract version-specific changelog section
                if (pkg.changelog) {
                  try {
                    // Use extract-changelog.sh script to extract version-specific section
                    const changelogPath = `${pkg.dir}/CHANGELOG.md`;
                    const extractedChangelog = execSync(
                      `./scripts/extract-changelog.sh "${changelogPath}" "${pkg.version}"`,
                      { encoding: 'utf8' }
                    ).trim();
                    
                    if (extractedChangelog) {
                      releaseNotes += `## Changelog\n\n${extractedChangelog}\n`;
                    }
                  } catch (error) {
                    // Handle missing changelog gracefully
                    console.warn(`âš ï¸  Could not extract changelog for ${pkg.name}@${pkg.version}:`, error.message);
                    // Fallback to simple message if extraction fails
                    releaseNotes += `## Changelog\n\nSee [CHANGELOG.md](${pkg.dir}/CHANGELOG.md) for details.\n`;
                  }
                }

                // Create the release
                const release = await github.rest.repos.createRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag_name: tagName,
                  name: `${pkg.name} v${pkg.version}`,
                  body: releaseNotes,
                  draft: false,
                  prerelease: false
                });
                
                console.log(`âœ… Created release: ${release.data.html_url}`);
                results.successful.push({
                  package: pkg.name,
                  version: pkg.version,
                  url: release.data.html_url
                });
              } catch (error) {
                // Log error but continue processing other packages
                console.error(`âŒ Failed to create release for ${tagName}:`, error.message);
                results.failed.push({
                  package: pkg.name,
                  version: pkg.version,
                  error: error.message
                });
                // Continue to next package instead of throwing
                continue;
              }
            }

            // Print summary
            console.log('\n' + '='.repeat(60));
            console.log('ðŸ“Š RELEASE SUMMARY');
            console.log('='.repeat(60));

            if (results.successful.length > 0) {
              console.log(`\nâœ… Successfully created ${results.successful.length} release(s):`);
              results.successful.forEach(r => {
                console.log(`   â€¢ ${r.package}@${r.version}`);
                console.log(`     ${r.url}`);
              });
            }

            if (results.skipped.length > 0) {
              console.log(`\nâ„¹ï¸  Skipped ${results.skipped.length} release(s):`);
              results.skipped.forEach(r => {
                console.log(`   â€¢ ${r.package}@${r.version} - ${r.reason}`);
              });
            }

            if (results.failed.length > 0) {
              console.log(`\nâŒ Failed to create ${results.failed.length} release(s):`);
              results.failed.forEach(r => {
                console.log(`   â€¢ ${r.package}@${r.version}`);
                console.log(`     Error: ${r.error}`);
              });
            }

            console.log('\n' + '='.repeat(60));

            // If all packages failed, throw error to fail the workflow
            if (results.failed.length > 0 && results.successful.length === 0) {
              throw new Error(`All ${results.failed.length} package release(s) failed`);
            }
